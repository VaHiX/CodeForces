# Problem: CF 2098 F - Homework
# https://codeforces.com/contest/2098/problem/F

"""
F. Homework

This problem involves determining whether one binary string can be transformed into another using specific operations on substrings.

Problem Overview:
Given two binary strings s and t of equal length n, we need to determine if s can be converted to t using a series of allowed operations:
1. Split the string into two halves x and y.
2. For each position i in the halves, perform one of:
   - x_i = (x_i + y_i) mod 2
   - y_i = (x_i + y_i) mod 2
   - Recursively apply the operations on x and y independently (if they have even length).

Algorithm:
The solution uses Gaussian elimination over GF(2) (binary field) to represent the transformation space.
- Each string is represented as a vector of bits.
- Transformations can be expressed as linear operations in GF(2).
- The key idea is to check if the "basis" of possible transformations from s can generate the target t.

Time Complexity: O(n log n)
Space Complexity: O(n)

Gaussian elimination technique with bit manipulation for solving systems of linear equations over GF(2).

Functions:
- gaussian_rank: Constructs a basis for the row space using Gaussian elimination.
- can_tr: Checks if transformation is possible by comparing bases of s and t.
- solve: Main function that reads input and outputs results.
"""

import sys

input = sys.stdin.readline


def gaussian_rank(rows):
    """
    Performs Gaussian elimination on rows to find a basis for the row space.
    Each row is treated as a bit vector and operations are done in GF(2).
    """
    basis = {}
    for v in rows:
        x = v
        while x:
            p = x.bit_length() - 1  # Find highest set bit
            if p in basis:
                x ^= basis[p]  # XOR with existing basis vector
            else:
                basis[p] = x
                break
    return basis


def can_tr(s, t):
    """
    Determines if string s can be transformed to string t.
    Uses Gaussian elimination to check if t's vector space is contained in s's.
    """
    n = len(s)
    g = n & -n  # Get the largest power of 2 dividing n
    r = n // g  # Number of rows for each block
    
    # Convert strings to list of integers representing bit vectors
    rows_s = [int(s[i * r : (i + 1) * r], 2) if r else 0 for i in range(g)]
    rows_t = [int(t[i * r : (i + 1) * r], 2) if r else 0 for i in range(g)]
    
    bs = gaussian_rank(rows_s)
    bt = gaussian_rank(rows_t)
    
    # If number of basis vectors differ, impossible to transform
    if len(bs) != len(bt):
        return False
        
    # Check if each vector in t's basis can be generated by s's basis
    for v in bt.values():
        x = v
        while x:
            p = x.bit_length() - 1
            if p in bs:
                x ^= bs[p]
            else:
                return False
    return True


def solve():
    t = int(input())
    answer = []
    for _ in range(t):
        int(input())  # Read n, but we don't use it directly after
        s = input().strip()
        t_str = input().strip()
        answer.append("Yes" if can_tr(s, t_str) else "No")
    sys.stdout.write("\n".join(answer))


if __name__ == "__main__":
    solve()


# https://github.com/VaHiX/codeForces/