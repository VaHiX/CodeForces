# Problem: CF 1734 F - Zeros and Ones
# https://codeforces.com/contest/1734/problem/F

"""
Thue-Morse Sequence Hamming Distance Calculation

This code computes the Hamming distance between two substrings of the infinite Thue-Morse sequence:
- First substring: S_0 S_1 ... S_{m-1}
- Second substring: S_n S_{n+1} ... S_{n+m-1}

The Thue-Morse sequence is constructed iteratively by:
1. Start with "0"
2. At each step, append a flipped version of the current string

Key algorithm:
- The Thue-Morse sequence exhibits a fractal-like structure where each block is generated by:
  S_{2k} = S_k and S_{2k+1} = not(S_k)
- To efficiently compute the Hamming distance for large n and m (up to 10^18), we use digit DP (Dynamic Programming)
  where we process bits from most significant to least significant
- The state of DP tracks:
  - Current bit position (i)
  - Parity: accumulated XOR of selected bits from the base sequence
  - Carry: used for managing the carry in bit addition during transition
  - Lim: whether the current digit is limited by the input number

Time Complexity: O(log^2(n) + log^2(m)) due to digit DP with memoization
Space Complexity: O(log(n) + log(m)) for memoization and recursion stack
"""

from functools import cache

for _ in range(int(input())):
    n, m = map(int, input().split())
    m -= 1
    n, m = map(lambda x: bin(x)[2:], [n, m])

    # Align binary strings by padding with leading zeros
    if len(n) < len(m):
        n = "0" * (len(m) - len(n)) + n
    else:
        m = "0" * (len(n) - len(m)) + m

    @cache
    def calc(i: int, parity: int, carry: int, lim: bool):
        # Base case: if we've processed all bits
        if i == len(m):
            # Return 1 if we have odd parity and no carry, indicating the difference
            return int(parity == 1 and carry == 0)
        
        res = 0
        # Determine upper bound for current digit
        up = int(m[i]) if lim else 1
        
        # Iterate through all possible values for current digit
        for d in range(up + 1):
            # Compute next carry based on arithmetic and previous carry
            for nc in range(2):
                # Check condition for valid transitions
                if int(nc + d + int(n[i]) >= 2) == carry:
                    res += calc(i + 1, parity ^ nc ^ int(n[i]), nc, lim and d == up)
        return res

    # Compute two separate counts for the final result
    print(calc(0, 0, 0, True) + calc(0, 1, 1, True))


# https://github.com/VaHiX/CodeForces/