# Problem: CF 2165 B - Marble Council
# https://codeforces.com/contest/2165/problem/B

"""
Problem: Marble Council

Purpose:
This code computes the number of distinct multisets that can be generated by partitioning a given multiset into non-empty parts,
and then selecting one mode from each part to form a new multiset. The result is computed modulo 998244353.

Algorithm:
The solution uses dynamic programming combined with combinatorial logic:
1. Count the frequency of each element in the input multiset.
2. Sort the frequencies in descending order.
3. Use dynamic programming to track how many ways we can form multisets up to a certain size.
4. For each group of elements with the same frequency, compute how many valid selections are possible
   while ensuring we count only those where the selected element is a mode in its part.
5. Final answer is computed by summing contributions from all stages, with adjustments for overcounting.

Time Complexity: O(N^2)
Space Complexity: O(N)

Input Format:
- First line: number of test cases t
- For each test case:
  - Line 1: n (size of multiset)
  - Line 2: n integers representing elements

Output Format:
- For each test case, print a single integer: number of distinct multisets modulo 998244353
"""

MOD = 998244353

for _ in range(int(input())):
    N = int(input())
    A = list(map(int, input().split()))

    # Count frequency of each element
    cnt = [0] * N
    for a in A:
        cnt[a - 1] += 1
    cnt.sort()
    cnt = [c for c in cnt if c != 0]  # Remove zeros, we only care about non-zero counts
    L = len(cnt)
    
    # B[i]: sum of frequencies from index i to L-1
    # C[i]: product of frequencies from index i to L-1
    B = [0] * (L + 1)
    C = [1] * (L + 1)
    for i in reversed(range(L)):
        B[i] = B[i + 1] + cnt[i]
        C[i] = C[i + 1] * cnt[i] % MOD

    ans = 0
    dp = [0] * (N + 1)
    dp[0] = 1  # Base case: one way to select 0 elements
    
    for i in range(L):
        limit = cnt[i] - B[i + 1]  # Determine valid selection limit for current group
        SUM = 0
        ndp = [0] * (N + 1)
        
        for j in range(N + 1):
            if limit <= j:  # If we allow choosing at least `cnt[i]` items at this step
                SUM += dp[j]
                SUM %= MOD
            if dp[j] == 0:
                continue
            # Copy over existing ways to form j elements
            ndp[j] += dp[j]
            ndp[j] %= MOD
            # Add ways to form j + cnt[i] elements by including one group of cnt[i] items
            ndp[j + cnt[i]] += dp[j] * cnt[i]
            ndp[j + cnt[i]] %= MOD
        ans += SUM * C[i + 1] % MOD
        ans %= MOD
        dp = ndp

    print((ans + C[0]) % MOD)


# https://github.com/VaHiX/CodeForces/