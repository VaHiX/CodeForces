# Problem: CF 1858 C - Yet Another Permutation Problem
# https://codeforces.com/contest/1858/problem/C

"""
Code Purpose:
This code solves the problem of finding a permutation of integers from 1 to n that maximizes the number of distinct GCD values when computing gcd(a[i], a[(i%n)+1]) for each i in the permutation. 

The approach uses a specific pattern:
1. For each odd number j from 1 to n (inclusive), we generate a sequence by repeatedly multiplying j by 2 until the product exceeds n.
2. These sequences are concatenated to form the final permutation.

Algorithms/Techniques:
- Greedy construction of permutation based on powers of 2
- Sequences generated by multiplying odd numbers by increasing powers of 2

Time Complexity: O(n log n)
Space Complexity: O(n)

This method ensures that we generate a permutation where the GCDs of adjacent elements (in cyclic order) produce a large number of distinct values.
"""

import sys
from io import StringIO


def main():
    out = StringIO()
    get_line = sys.stdin.readline

    def get_ints():
        return map(int, get_line().split(" "))

    def get_int():
        return int(get_line())

    for i in range(get_int()):
        n = get_int()
        ans = []
        # Iterate through all odd numbers from 1 to n
        for j in range(1, n + 1, 2):
            k = j
            # Generate sequence by multiplying j by powers of 2 while k <= n
            while k <= n:
                ans.append(k)
                k *= 2
        out.write(" ".join(map(str, ans)))
        out.write("\n")

    sys.stdout.write(out.getvalue())


if __name__ == "__main__":
    main()
"""
1 2 4 8 3 6 12 5 10 7 9
"""


# https://github.com/VaHiX/CodeForces/