# Problem: CF 1877 C - Joyboard
# https://codeforces.com/contest/1877/problem/C

"""
Purpose: Solve the Joyboard problem where we need to count the number of valid ways to assign a value to the last slot 
         such that the resulting array has exactly k distinct values. The array is generated by applying modulo operations 
         from right to left.

Algorithms/Techniques:
- Mathematical analysis of the modulo chain to determine valid ranges for the last element
- Case-based logic for k = 1, k = 2, and k > 2
- Efficient computation using integer division and arithmetic sums

Time Complexity: O(1) per test case, as all operations are constant time.
Space Complexity: O(1), only using a fixed amount of extra space regardless of input size.
"""

import sys

input = sys.stdin.readline


def sieve_of_eratosthenes(n):
    sieve = [True] * (n + 1)
    sieve[0], sieve[1] = False, False
    primes = []
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            primes.append(current)
            for multiple in range(current * current, n + 1, current):
                sieve[multiple] = False
    for current in range(int(n**0.5) + 1, n + 1):
        if sieve[current]:
            primes.append(current)
    return primes


def inp():
    return int(input())


def inlt():
    return list(map(int, input().split()))


def insr():
    s = input()
    return list(s[: len(s) - 1])


def invr():
    return map(int, input().split())


def count_divisible_by(num, limit):
    return limit // num


def sum_range(a, b):
    return b * (b + 1) // 2 - a * (a - 1) // 2


def Yes():
    print("Yes")


def No():
    print("No")


def solve():
    n, m, k = invr()
    # If k is greater than 3, it's impossible to have more than 3 distinct values because of the modulo constraints
    if k > 3:
        print(0)
    # If k is 1, we can always assign any value up to m as long as the entire sequence ends up with one value
    elif k == 1:
        print(1)
    # If k is 2, calculate possible values using the modulo behavior and ranges
    elif k == 2:
        # This formula computes: min(n, m) + max((m // n - 1), 0)
        # min(n, m) is for the base case of valid slots when n <= m
        # max((m // n - 1), 0) adds additional possibilities if m // n > 1
        print(min(n, m) + max((m // n - 1), 0))
    else:
        # For k = 3, the count is derived from the difference between m and a computed minimum
        # max(0, m - n - max((m // n - 1), 0)) accounts for cases where values exceed the allowed bounds
        print(max(0, m - n - max((m // n - 1), 0)))


def main():
    for _ in range(inp()):
        solve()


main()


# https://github.com/VaHiX/CodeForces/