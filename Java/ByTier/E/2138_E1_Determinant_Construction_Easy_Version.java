// Problem: CF 2138 E1 - Determinant Construction (Easy Version)
// https://codeforces.com/contest/2138/problem/E1

/*
 * Problem: E1. Determinant Construction (Easy Version)
 * Purpose: Construct a square matrix M with determinant equal to x, where:
 *          - Side length <= 80
 *          - Each element is -1, 0, or 1
 *          - Each row/column has at most 3 non-zero elements
 *          - Matrix always exists (provably)
 *
 * Algorithm:
 *   - For x = 0, return identity matrix of size 1 (det = 1) and change one entry to 0.
 *   - For x = 1, return identity matrix.
 *   - For other values:
 *     * Find small y such that the sequence generated by Euclidean algorithm (x,y) has length <= LIMIT (80)
 *     * Try multiple random candidates until valid y found; fallback to linear search
 *     * Generate matrix using recursive construction based on sequence from Euclidean steps
 *
 * Time Complexity: O(T * sqrt(x)) in average case, since we perform a limited number of trials
 * Space Complexity: O(LIMIT^2) for the matrix storage (max 80x80), and additional O(LIMIT) for sequence tracking
 */

import java.io.*;
import java.util.*;

public class Main {
    static final int LIMIT = 80;
    static Random rng = new Random();
    
    public static void main(String[] args) throws Exception {
        FastScanner sc = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int T = sc.nextInt();
        while (T-- > 0) {
            int x = sc.nextInt();
            if (x == 0) {
                out.println(1);
                out.println(0);
                continue;
            }
            if (x == 1) {
                out.println(1);
                out.println(1);
                continue;
            }
            int y = 1;
            boolean found = false;
            double phi = (Math.sqrt(5.0) - 1.0) / 2.0;
            int start = Math.max(1, (int)(phi * x) - 2);
            // Search around golden ratio approximations for fast convergence
            for (int cand = start; cand <= Math.min(x-1, start+200) && !found; cand++) {
                if (workLen(x, cand) <= LIMIT) { y = cand; found = true; }
            }
            int trials = 0;
            // If not found above, do random sampling
            while (!found && trials < 2000) {
                int cand = rng.nextInt(x-1) + 1;
                if (workLen(x, cand) <= LIMIT) { y = cand; found = true; }
                trials++;
            }
            // Final fallback to scan all values
            if (!found) {
                for (int cand = 1; cand < x && !found; cand++) {
                    if (workLen(x, cand) <= LIMIT) { y = cand; found = true; }
                }
            }
            genAndPrint(x, y, out);
        }
        out.flush();
    }
    
    // Calculates length of Euclidean algorithm steps for (x,y), up to LIMIT
    static int workLen(int x, int y) {
        int steps = 0;
        while (y != 0 && steps <= LIMIT) {
            steps++;
            int tmp = y;
            if (x > y) y = x - y;
            else y = y - x;
            x = tmp;
        }
        if (x > 1) return Integer.MAX_VALUE; // Not valid path
        return steps;
    }
    
    // Generates matrix from Euclidean sequence using recursive construction
    static void genAndPrint(int x, int y, PrintWriter out) {
        ArrayList<Integer> seq = new ArrayList<>();
        seq.add(x);
        seq.add(y);
        int a = x, b = y;
        while (!(a == 2 && b == 1)) {
            int tmp = b;
            if (a > b) b = a - b;
            else b = b - a;
            a = tmp;
            seq.add(b);
        }
        int pre = seq.get(seq.size()-1);
        seq.remove(seq.size()-1);
        int[][] ans = new int[1][1];
        ans[0][0] = 1;
        while (!seq.isEmpty()) {
            int cur = seq.get(seq.size()-1);
            seq.remove(seq.size()-1);
            int oldn = ans.length;
            int n = oldn + 1;
            int[][] bmat = new int[n][n];
            for (int i=0; i<oldn; i++)
                for (int j=0; j<oldn; j++)
                    bmat[i][j] = ans[i][j];
            bmat[n-1][n-1] = 1;
            bmat[n-1][n-2] = 1;
            bmat[n-2][n-1] = (cur > pre ? -1 : 1);
            pre = cur;
            ans = bmat;
        }
        int n = ans.length;
        out.println(n);
        for (int i=0; i<n; i++) {
            for (int j=0; j<n; j++) {
                out.print(ans[i][j]);
                if (j+1 < n) out.print(" ");
            }
            out.println();
        }
    }
    
    static class FastScanner {
        private final InputStream in;
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        FastScanner(InputStream in) { this.in = in; }
        private int read() throws IOException {
            if (ptr >= len) {
                ptr = 0;
                len = in.read(buffer);
                if (len <= 0) return -1;
            }
            return buffer[ptr++];
        }
        int nextInt() throws IOException {
            int c, sign=1, val=0;
            do { c = read(); } while (c <= ' ');
            if (c=='-') { sign=-1; c=read(); }
            for (; c>' '; c=read()) val=val*10+c-'0';
            return val*sign;
        }
    }
}


// https://github.com/VaHiX/codeForces/