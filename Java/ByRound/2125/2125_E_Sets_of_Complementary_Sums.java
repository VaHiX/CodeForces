// Problem: CF 2125 E - Sets of Complementary Sums
// https://codeforces.com/contest/2125/problem/E

/**
 * E. Sets of Complementary Sums
 * 
 * Problem Description:
 * A set Q is called a set of complementary sums if it can be generated by:
 * 1. Choosing an array a of m positive integers.
 * 2. Calculating the sum s of all elements in a.
 * 3. Adding (s - a_i) for each element a_i to the set.
 * 
 * The task is to count how many distinct such sets exist with exactly n elements,
 * where each element lies between 1 and x (inclusive).
 * 
 * Approach:
 * Uses dynamic programming to compute valid combinations of values.
 * For given n, x, it computes number of ways to form valid sets by using
 * transitions based on partial sums and inclusion-exclusion logic.
 * 
 * Time Complexity: O(n * x)
 * Space Complexity: O(x)
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    static final int MOD = 998244353;
    static final int MAX_N = 200005; 
    static int[] f = new int[MAX_N]; // DP array for current state
    static int[] g = new int[MAX_N]; // DP array for next state
    
    /**
     * Updates value x by adding y, handles modular arithmetic and negative values.
     */
    static int upd(int x, int y) {
        x = (x + y) % MOD;
        if (x < 0) {
            x += MOD;
        }
        return x;
    }
    
    /**
     * Solves the problem for a given test case (n and x).
     */
    static void solv(BufferedReader br) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        
        // Early termination conditions
        if (n > x) {
            System.out.println(0);
            return;
        }
        if (n == 1) {
            System.out.println(x % MOD);
            return;
        }
        
        // If sum of first n-1 numbers exceeds x, no valid solution exists
        long sum = 1L * n * (n - 1) / 2;
        if (sum >= x) {
            System.out.println(0);
            return;
        }
        
        // Initialize f array to zero
        for (int i = 0; i <= x; i++) {
            f[i] = 0;
        }
        f[0] = 1; // Base case
        
        // DP iteration over the size of subset (from 1 to n-1)
        for (int i = 1; i <= n - 1; i++) {
            // Reset g array to zero
            for (int j = 0; j <= x; j++) {
                g[j] = 0;
            }
            
            // Special handling when processing the final step (`i == n - 1`)
            if (i == n - 1) {
                // Transition for last step: increase index by 1 and use cumulative sum
                for (int j = 0; j <= x; j++) {
                    if (j + 1 <= x) {
                        g[j + 1] = upd(g[j + 1], f[j]);
                    }
                }
                
                // Forward propagation: g[d + i] += g[d]
                for (int j = 0; j + i <= x; j++) {
                    g[j + i] = upd(g[j + i], g[j]);
                }
            } else {
                // General case: move elements forward with addition of `i`
                for (int j = 0; j + 1 + i <= x; j++) {
                    g[j + 1 + i] = upd(g[j + 1 + i], f[j]);
                }
                
                // Forward propagation similar to above
                for (int j = 0; j + i <= x; j++) {
                    g[j + i] = upd(g[j + i], g[j]);
                }
            }
            
            // Copy g back to f for the next iteration
            System.arraycopy(g, 0, f, 0, x + 1);
        }
        
        // Final computation: compute all valid answers for each d
        int ans = 0;
        for (int d = 1; d < x; d++) {
            // Calculate maximum value allowed based on constraints
            int maxVal = Math.max(0, x - (d + n - 1) + 1);
            ans = upd(ans, (int) ((1L * f[d] * maxVal) % MOD));
        }
        
        System.out.println(ans);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            solv(br);
        }
    }
}


// https://github.com/VaHiX/CodeForces/