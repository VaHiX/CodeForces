// Problem: CF 1781 F - Bracket Insertion
// https://codeforces.com/contest/1781/problem/F

/*
 * Problem: F. Bracket Insertion
 * 
 * Purpose:
 * This code computes the probability that a bracket sequence generated by a specific
 * random process will be regular (i.e., valid parentheses). The process involves
 * successively inserting either "()" or ")(" at a randomly chosen position.
 * 
 * Algorithm:
 * The solution uses dynamic programming with memoization. It tracks the number of
 * unmatched opening brackets at each step and calculates the probability of ending
 * with a valid sequence. The final answer is adjusted for the Catalan number
 * normalization factor.
 * 
 * Time Complexity: O(n^3)
 * Space Complexity: O(n^2)
 * 
 * Methods:
 * - Preprocessing modular inverse using extended Euclidean algorithm (Fermat's little theorem)
 * - Dynamic Programming on bracket balance states
 * - Modular arithmetic for probability calculations
 */

#include <iostream>
using namespace std;

const long long MOD = 998244353;

// I[i] stores modular inverse of i mod MOD
int n, p, I[10004], dp[505][505];

int main() {
  cin >> n >> p;
  
  // Precompute modular inverses using Fermat's little theorem
  // I[i] = modular inverse of i mod MOD
  for (int i = (I[1] = 1) + 1; i <= 10000; i++)
    I[i] = 1ll * (MOD - MOD / i) * I[MOD % i] % MOD;
  
  // Convert probability p from q*10^-4 to modular arithmetic
  p = 1ll * p * I[10000] % MOD;
  
  // Initialize base case - 0 operations, 0 unmatched brackets
  for (int i = 0; i <= n; i++)
    dp[0][i] = 1;
  
  // DP transition
  // dp[i][j]: probability of having j unmatched brackets after i insertions
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= n - i; j++) {
      // Try all possible positions where current bracket pair is inserted
      for (int k = 1; k <= i; k++) {
        // Add probability of inserting "()" with probability p
        dp[i][j] = (dp[i][j] + (1ll * p * dp[k - 1][j + 1] + 
                        // Add probability of inserting ")(" with probability (1-p)
                        (j ? 1ll * (MOD + 1 - p) * dp[k - 1][j - 1] : 0)) % 
                        MOD * dp[i - k][j] % MOD * I[k]) % MOD;
      }
    }
  }
  
  // Final answer is dp[n][0] (probability of being balanced at end)
  int ans = dp[n][0];
  
  // Adjust for normalization (multiply by Catalan number factor)
  for (int i = 2; i <= n; i++)
    ans = 1ll * ans * i % MOD * I[(i << 1) - 1] % MOD;
  
  cout << ans << '\n';
}


// https://github.com/VaHiX/CodeForces/