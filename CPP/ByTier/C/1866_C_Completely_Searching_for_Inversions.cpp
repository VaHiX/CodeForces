// Problem: CF 1866 C - Completely Searching for Inversions
// https://codeforces.com/contest/1866/problem/C

/*
C. Completely Searching for Inversions
time limit per test2 seconds
memory limit per test512 megabytes

Algorithms/Techniques: DFS traversal of a directed acyclic graph (DAG), Dynamic Programming on Trees,
Counting inversions with prefix sums and subtree aggregation.

Time Complexity: O(N + M) where N is number of vertices and M is total number of edges.
Space Complexity: O(N + M) for storing the adjacency list and recursive stack space.

The problem involves computing inversions in a sequence generated by DFS traversal of a DAG.
Each edge has weight 0 or 1. The DFS generates a sequence Z, and we compute how many pairs (i,j)
with i < j satisfy Z[i] > Z[j]. This is done using a recursive DP on the tree structure,
tracking counts of 0s and 1s in subtrees to calculate inversions efficiently.
*/

#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>

#define int long long
using namespace std;
const int N = 100005;
const int mod = 998244353;
int n, ans[N], f[N][2];
vector<pair<int, int>> v[N];
bool vis[N];

void dfs(int x) {
  if (vis[x])
    return;
  vis[x] = 1;
  for (auto u : v[x]) {
    int y = u.first, w = u.second;
    // Add contribution of edges with weight 0 to the current vertex's inversion count
    ans[x] = (ans[x] + (w == 0) * f[x][1] % mod) % mod;
    // Update the count for this edge's weight in the current node
    f[x][w]++;
    dfs(y);
    // Compute contribution of subtree rooted at y to inversion count at current node
    int res = ((f[y][0] * f[x][1] % mod) + ans[y]) % mod;
    ans[x] = (ans[x] % mod + res) % mod;
    // Merge subtree counts into the current node
    (f[x][0] += f[y][0]) %= mod;
    (f[x][1] += f[y][1]) %= mod;
  }
}

signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; i++) {
    int m, x, y;
    cin >> m;
    for (int j = 1; j <= m; j++) {
      cin >> x >> y;
      v[i].push_back(make_pair(x, y));
    }
  }
  dfs(1);
  cout << ans[1] << '\n';
  return 0;
}


// https://github.com/VaHiX/codeForces/