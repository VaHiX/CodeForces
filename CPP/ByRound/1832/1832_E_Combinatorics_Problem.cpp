// Problem: CF 1832 E - Combinatorics Problem
// https://codeforces.com/contest/1832/problem/E

/*
 * Problem: E. Combinatorics Problem
 * 
 * Purpose: 
 *   Given an array a generated by a recurrence relation and a fixed k, compute a new array b where each element
 *   is a weighted sum of previous elements using binomial coefficients. Then compute the XOR of c_i = b_i * i.
 * 
 * Algorithms/Techniques:
 *   - Precompute binomial coefficients using dynamic programming with prefix sums
 *   - Efficiently calculate contributions using cumulative sums
 *   - Use modular arithmetic to prevent overflow
 * 
 * Time Complexity: O(n * k)
 *   - n iterations over the array
 *   - k operations per iteration for updating dp array
 * 
 * Space Complexity: O(k)
 *   - We only store the dp array of size k+1 (for indices 0 to k)
 * 
 * Note:
 *   - The array a is generated iteratively using the formula a[i] = (a[i-1] * x + y) % m
 *   - The binomial coefficient (i-j+1 k) is computed implicitly via a DP array
 *   - Final output is the XOR of c_i = b_i * i (without modulo)
 */

#include <iostream>

using namespace std;
const int mod = 998244353;
int n, a[10000003], x, y, m, dp[6], k;
long long ans = 0;
int main() {
  cin >> n >> a[1] >> x >> y >> m >> k;
  for (int i = 1; i <= n; i++) {
    // Generate next element in array a using recurrence relation
    if (i > 1)
      a[i] = (1ll * a[i - 1] * x + y) % m;
    
    // Update dp[0] with current value of a[i]
    dp[0] = (dp[0] + a[i]) % mod;
    
    // Update dp array in reverse order to simulate prefix sums of binomial coefficients
    for (int j = k; j; j--)
      dp[j] = (dp[j] + dp[j - 1]) % mod;
    
    // Accumulate the XOR of c_i = b_i * i
    ans = ans ^ 1ll * dp[k] * i;
  }
  cout << ans;
}


// https://github.com/VaHiX/CodeForces/