// Problem: CF 1728 F - Fishermen
// https://codeforces.com/contest/1728/problem/F

/*
Algorithm: This code solves a complex optimization problem using a combination of sorting, binary search, and bipartite matching (Hungarian algorithm-like approach).
The goal is to find an ordering of fishermen such that the sum of "fake" fish sizes is minimized.

Approach:
1. Generate all possible values that can be generated by multiplying fish sizes with integers.
2. Sort and deduplicate these values.
3. Build a bipartite graph where left side represents possible values (b[i]) and right side represents fishermen (a[i]).
4. Use maximum matching to assign each fisherman to a value in a way that minimizes total sum.

Time Complexity: O(n^2 * log(n) + m * n) where m is the number of unique products, n is the number of fishermen.
Space Complexity: O(n^2 + m) for storing the graph and intermediate arrays.

*/
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <vector>

using namespace std;
int n, m, a[1001], b[1000001], vis[1001], match[1001];
long long ans, tot;
vector<int> G[1000001];
bool dfs(int x) {
  // DFS for finding augmenting path in bipartite graph
  for (int y : G[x]) {
    if (!vis[y]) {
      vis[y] = 1;
      // If y is unmatched or we can find an augmenting path from match[y]
      if (!match[y] || dfs(match[y])) {
        match[y] = x;
        return true;
      }
    }
  }
  return false;
}
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    scanf("%d", &a[i]);
    // Generate all products of a[i] with j from 1 to n
    for (int j = 1; j <= n; j++)
      b[++m] = a[i] * j;
  }
  // Sort and deduplicate all generated products
  sort(b + 1, b + 1 + m);
  m = unique(b + 1, b + 1 + m) - b - 1;
  // Build bipartite graph: for each product value, link it to fishermen who could generate it
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
      G[lower_bound(b + 1, b + 1 + m, a[i] * j) - b].push_back(i);
  // Try to match each possible value to a fisherman to minimize total cost
  for (int i = 1; i <= m && tot <= n; i++)
    if (dfs(i)) {
      tot++; // Increment matched count
      ans += b[i]; // Add the value to result
      memset(vis, 0, sizeof(vis)); // Reset visited array for next iteration
    }
  printf("%lld", ans);
  return 0;
}


// https://github.com/VaHiX/CodeForces/