// Problem: CF 1482 B - Restore Modulo
// https://codeforces.com/contest/1482/problem/B

/*
B. Restore Modulo
Purpose:
This code determines whether an array can be generated by a modulo sequence with parameters n, m, c, s.
If it can, it finds the maximum possible value of m and a valid c.

Algorithms/Techniques:
- Linear scan through array to determine differences between consecutive elements
- Detecting patterns in positive and negative differences
- Modular arithmetic to validate and reconstruct the sequence

Time Complexity: O(n) for each array
Space Complexity: O(n) for storing the input array
*/

#include <cstdio>
#include <vector>
int main() {
  long t;
  scanf("%ld", &t);
  while (t--) {
    long n;
    scanf("%ld", &n);
    std::vector<long> a(n);
    for (long p = 0; p < n; p++) {
      scanf("%ld", &a[p]);
    }
    bool possible(true);
    long poscnt(0), negcnt(0), posdiff(0), negdiff(0);
    // Loop through array to compute differences and count positive/negative diffs
    for (long p = 1; possible && p < n; p++) {
      long diff = a[p] - a[p - 1];
      if (diff > 0) {
        ++poscnt;
        if (!posdiff) {
          posdiff = diff;
        } else if (diff != posdiff) {
          possible = false;
        }
      } else if (diff < 0) {
        ++negcnt;
        if (!negdiff) {
          negdiff = diff;
        } else if (diff != negdiff) {
          possible = false;
        }
      }
    }
    // If array is constant, m can be arbitrary large
    if (!poscnt && !negcnt) {
      puts("0");
      continue;
    }
    // Check if there are missing differences (i.e. if some elements are equal)
    if (poscnt + negcnt < n - 1) {
      possible = false;
    }
    if (!possible) {
      puts("-1");
      continue;
    }
    // If only increasing or decreasing, m can be arbitrary large
    if (!poscnt || !negcnt) {
      puts("0");
      continue;
    }
    // Calculate key values for the reconstruction
    long c = posdiff;
    long m = posdiff - negdiff;
    // If start value makes sequence invalid, set impossible
    if (a[0] >= m) {
      possible = false;
    }
    // Check that the reconstructed sequence matches original
    for (long p = 1; possible && p < n; p++) {
      long x = (a[p - 1] + c) % m;
      if (x != a[p]) {
        possible = false;
      }
    }
    if (possible) {
      printf("%ld %ld\n", m, c);
    } else {
      puts("-1");
    }
  }
}


// https://github.com/VaHiX/codeForces/