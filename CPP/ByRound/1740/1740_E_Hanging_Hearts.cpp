// Problem: CF 1740 E - Hanging Hearts
// https://codeforces.com/contest/1740/problem/E

/*
Code Purpose:
This code solves the problem of finding the maximum length of the longest non-decreasing subsequence 
of a sequence s generated by a specific process involving tree-like card structure and dynamic updates. 
The strategy uses a reverse traversal of the tree and dynamic programming to compute optimal values.

Algorithms/Techniques:
- Tree traversal (bottom-up)
- Dynamic Programming
- Greedy optimization with update propagation

Time Complexity: O(n)
Space Complexity: O(n)

The algorithm works by:
1. Reading the parent relationships of cards to form a tree structure.
2. Traversing the tree from leaves to root.
3. For each node, computing the maximum non-decreasing subsequence length ending at that node.
4. Propagating the computed values up the tree to accumulate results.
5. Returning the result for the root node (card 1).

This dynamic programming approach efficiently computes the answer by considering the effect 
of each card's value update on its parent's potential subsequence length.
*/

#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;
int main() {
  int n;
  cin >> n;
  vector<int> p(n + 1);  // Parent array: p[i] is the parent of card i
  vector<int> dp(n + 1); // dp[i] stores the maximum length of non-decreasing subsequence ending at card i
  vector<int> h(n + 1, 1); // h[i] stores the height or contribution of card i in the tree structure
  
  for (int i = 2; i <= n; i++) {
    cin >> p[i]; // Read parent of card i
  }
  
  // Traverse from leaf to root (reverse order)
  for (int i = n; i >= 1; i--) {
    // Update dp[i] with current height h[i]
    dp[i] = max(dp[i], h[i]);
    // Accumulate the dp value to the parent node
    dp[p[i]] += dp[i];
    // Increase the height of the parent node
    h[p[i]] = max(h[p[i]], h[i] + 1);
  }
  
  // Output the result for the root node (card 1)
  cout << dp[1] << endl;
}


// https://github.com/VaHiX/CodeForces/