// Problem: CF 1611 C - Polycarp Recovers the Permutation
// https://codeforces.com/contest/1611/problem/C

/*
 * Problem: Polycarp Recovers the Permutation
 * 
 * Purpose: Given a final array 'a' generated by a specific process of picking
 *          minimums from leftmost and rightmost ends of a permutation 'p',
 *          reconstruct any valid initial permutation 'p' that could produce 'a'.
 * 
 * Algorithm:
 *   - Reverse simulation approach:
 *     - Start with the final array 'a' and simulate the reverse process.
 *     - The last element added to 'a' must be the last remaining element in 'p'.
 *     - At each step, we check if the current leftmost or rightmost element of 'a'
 *       could have been the picked element in the original process.
 *     - The key insight is that the largest number (n) must have been the last
 *       pick, so it must be at either the beginning or end of 'a'.
 *     - Use a deque to simulate construction of the permutation from both ends.
 * 
 * Time Complexity: O(n) per test case.
 * Space Complexity: O(n) due to storage of the deque and input arrays.
 */

#include <cstdio>
#include <deque>
#include <vector>
int main() {
  long t;
  scanf("%ld", &t);
  while (t--) {
    long n;
    scanf("%ld", &n);
    std::vector<long> a(n);
    for (long p = 0; p < n; p++) {
      scanf("%ld", &a[p]);
    }
    // Check if the maximum element n is at one of the ends of array a
    // If not, there's no valid permutation
    if (a[0] != n && a.back() != n) {
      puts("-1");
      continue;
    }
    std::deque<long> d; // Deque to build the permutation from both sides
    long left(0), right(n - 1); // Pointers to track current left and right in a
    while (left <= right) {
      // Compare the values at left and right ends of current a
      // Pick the smaller one to simulate reverse process
      if (a[left] < a[right]) {
        d.push_front(a[left]);  // Add to front
        ++left;
      } else {
        d.push_back(a[right]);  // Add to back
        --right;
      }
    }
    // Output the constructed permutation
    for (long p = 0; p < d.size(); p++) {
      printf("%ld ", d[p]);
    }
    puts("");
  }
}


// https://github.com/VaHiX/CodeForces/