// Problem: CF 1740 E - Hanging Hearts
// https://codeforces.com/contest/1740/problem/E

ï»¿/*
Code Purpose:
This code solves the "Hanging Hearts" problem where we have n cards arranged in a tree structure (with card 1 at the root), and we need to find the maximum length of the longest non-decreasing subsequence (LNDS) of a sequence s generated by a specific process. 
The process involves choosing leaves of the tree, appending their values to s, possibly updating parent values, and removing cards. 
The approach uses dynamic programming principles on a tree, where for each node we track how many nodes can form a valid chain ending at that node and how many additional nodes we can merge from children.
Key algorithmic techniques used:
- Tree traversal
- Dynamic Programming on trees
- Greedy selection of leaves

Time Complexity: O(n)
Space Complexity: O(n)

*/

using System;
using System.Collections.Generic;
using System.Linq;
namespace Compete2 {
partial class MainClass {
  public static void Main(string[] args) {
    int count = 1;
    List<string> output = new List<string>();
    for (int z = 0; z < count; z++) {
      var n = int.Parse(Console.ReadLine());
      var a =
          Console.ReadLine().Split(' ').Select(qw => int.Parse(qw)).ToList();
      long o = 0;
      int[] p = new int[n]; // p[i] represents the count of nodes potentially forming a chain at node i
      int[] s = new int[n]; // s[i] represents the number of additional nodes that can be merged to the chain at node i
      for (int i = n - 2; i >= 0; i--) {
        int d = a[i] - 1; // parent of current card i+1, converting to 0-based index
        p[i + 1]++; // increment count of the current card
        if (s[i + 1] > 0)
          s[i + 1]--; // adjust s for current card if needed
        if (p[i + 1] > p[d]) { // if the current node's chain is longer than parent's
          s[d] += p[d]; // add the parent's chain length to s
          p[d] = p[i + 1]; // update parent's chain to current chain length
          s[d] += s[i + 1]; // add the current card's s to parent's s
        } else {
          s[d] += p[i + 1]; // add current card's p to parent's s
          s[d] += s[i + 1]; // add current card's s to parent's s
        }
      }
      p[0]++; // increment count of root node
      if (s[0] > 0)
        s[0]--; // adjust s for root
      o = s[0] + p[0]; // total length of the longest non-decreasing subsequence
      output.Add(o.ToString());
    }
    output.ForEach(d => Console.WriteLine(d));
  }
}
}


// https://github.com/VaHiX/CodeForces/