// Problem: CF 1671 E - Preorder
// https://codeforces.com/contest/1671/problem/E
 
/*
Algorithm: DFS with memoization to count distinct preorder strings
Techniques: 
- Tree traversal using DFS
- Dynamic Programming with memoization
- String comparison and swapping logic
- Modular arithmetic for large results
 
Time Complexity: O(2^n) where n is the input parameter, due to the recursive DFS traversing all nodes
Space Complexity: O(2^n) for the recursion stack and storing intermediate results
 
The problem involves a perfect binary tree where we can swap children of non-leaf nodes,
and we need to count the number of distinct preorder traversal strings possible.
Each node's preorder string is defined recursively:
- For a leaf: it's simply the character at that node
- For a non-leaf: it's the character + preorder of left child + preorder of right child
We use DFS to process the tree and for each node compute how many distinct strings
can be generated by swapping children when needed.
*/
using System;
using System.Collections.Generic;
using System.Linq;
namespace Compete2 {
partial class MainClass {
  public static void Main(string[] args) {
    int count = 1;
    List<string> output = new List<string>();
    for (int z = 0; z < count; z++) {
      var n = long.Parse(Console.ReadLine());
      var b = Console.ReadLine();
      long o = DFS(1, b).Item1 % 998244353;
      output.Add(o.ToString());
    }
    output.ForEach(d => Console.WriteLine(d));
  }
  public static Tuple<long, string> DFS(int id, string b) {
    // Base case: if id*2 > b.Length, then this is a leaf node
    if (id * 2 > b.Length) {
      Tuple<long, string> t = new Tuple<long, string>(1, b[id - 1].ToString());
      return t;
    } else {
      // Recursively get results for left and right children
      var t1 = DFS(id * 2, b);   // Left child
      var t2 = DFS(id * 2 + 1, b); // Right child
      
      long l = 0;
      // Ensure t1's string is lexicographically smaller than or equal to t2's string
      // This helps in canonicalizing the order for counting distinct structures
      if (string.Compare(t1.Item2, t2.Item2) > 0) {
        var tn = t2;
        t2 = t1;
        t1 = tn;
      }
      // Calculate the number of ways to form the result
      l = t1.Item1 * t2.Item1;
      l = l % 998244353;
      // If the strings of left and right children are different,
      // we can swap them, giving us 2 possibilities
      if (t1.Item2 != t2.Item2)
        l *= 2;
      l = l % 998244353;
      
      // Combine current node's character with left and right preorder strings
      Tuple<long, string> t = new Tuple<long, string>(
          l, b[id - 1].ToString() + t1.Item2 + t2.Item2);
      return t;
    }
  }
}
}
 
 
// https://github.com/VaHiX/CodeForces/