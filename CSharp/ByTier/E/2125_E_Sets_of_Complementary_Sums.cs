// Problem: CF 2125 E - Sets of Complementary Sums
// https://codeforces.com/contest/2125/problem/E

/*
 * Problem: E. Sets of Complementary Sums
 * 
 * Purpose: Count the number of distinct sets of complementary sums where:
 *   - Each set contains exactly n elements.
 *   - Each element is an integer from 1 to x.
 * 
 * Key Concepts:
 * A set Q is a set of complementary sums if it can be generated by:
 *   1. Choosing an array 'a' of m positive integers.
 *   2. Calculating sum s = sum(a).
 *   3. For each element a_i, adding (s - a_i) to Q.
 * 
 * Observations:
 * - The set Q depends on the total sum s of array a and individual values in a.
 * - Let's say we have an array with elements a1, ..., am and sum s.
 *   Then the set Q = {s - a1, ..., s - am}.
 *   These are just complements of elements in a relative to s.
 * 
 * Algorithm:
 * 1. Use dynamic programming (DP) approach to count valid combinations:
 *    - For each number of elements (from 2 to n), compute how many ways
 *      we can form sums using previous steps.
 * 2. For final answer:
 *    - Sum up all the contributions from valid sets.
 * 
 * Time Complexity: O(n * x)
 * Space Complexity: O(x)
 * 
 * Techniques Used:
 * - Dynamic Programming (DP)
 * - Modular arithmetic
 * - Mathematical optimization for computing combinations
 */

using System.Text;

namespace SetsOfComplementarySums {
  class Program {
    static long Solve() {
      long n = Next();
      long x = Next();
      
      // Minimum possible sum of n positive integers is 1+2+...+n = n*(n+1)/2
      long min = n * (n + 1) / 2;
      
      // If minimum sum exceeds x+1, then impossible to have such a set
      if (min > x + 1)
        return 0;

      // Edge case: only one element in the set
      if (n == 1)
        return x;

      // dp1[i] stores number of ways to achieve sum i with some subset
      long[] dp1 = new long[x + 2];
      
      // Initial state: minimum sum is achievable in exactly one way
      dp1[min] = 1;

      // Loop over sizes from 2 to n-1
      for (long j = 2; j < n; j++) {
        // For each possible sum, update using previous values
        for (long i = min; i + j < dp1.Length; i++) {
          if (dp1[i] != 0)
            dp1[i + j] = (dp1[i + j] + dp1[i]) % mod;
        }
      }

      long ans = 0;
      
      // Compute contribution of each possible sum to final answer
      for (long i = min; i < dp1.Length; i++) {
        // Contribution formula: dp1[i] * ((x+2 - i) * (x+3 - i) / 2)
        ans += dp1[i] * ((x + 2 - i) * (x + 3 - i) / 2 % mod) % mod;
      }

      return ans % mod;
    }
    
    const int mod = 998244353;

    static void Main(string[] args) {
      long t = Next();
      for (int i = 0; i < t; i++)
        writer.WriteLine(Solve());
      writer.Flush();
    }

    static long Next() {
      int c;
      int m = 1;
      long res = 0;
      do {
        c = reader.Read();
        if (c == '-')
          m = -1;
      } while (c < '0' || c > '9');
      
      res = c - '0';
      while (true) {
        c = reader.Read();
        if (c < '0' || c > '9')
          return m * res;
        res *= 10;
        res += c - '0';
      }
    }

    static readonly StreamReader reader = new(
        Console.OpenStandardInput(1024 * 10), Encoding.ASCII, false, 1024 * 10);
    static readonly StreamWriter writer =
        new(Console.OpenStandardOutput(1024 * 10), Encoding.ASCII, 1024 * 10);
  }
}


// https://github.com/VaHiX/codeForces/